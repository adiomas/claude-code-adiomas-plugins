#!/usr/bin/env bash
# claude-agi - External orchestrator for autonomous Claude Code sessions
# Manages session lifecycle, handles handoffs, and enables true multi-session autonomy
#
# Usage:
#   claude-agi                     Start new execution (interactive)
#   claude-agi --continue          Resume from checkpoint
#   claude-agi --overnight         Start overnight mode (no prompts, auto-restart)
#   claude-agi --verbose           Show detailed debug output
#   claude-agi --quiet             Minimal output (only errors)
#   claude-agi --status            Show execution status
#   claude-agi --cancel            Cancel execution and cleanup
#
# Version: 4.0.0

set -euo pipefail

# Configuration
readonly VERSION="4.2.2"
readonly STATE_DIR=".claude/auto-execution"
readonly STATE_FILE="$STATE_DIR/state.yaml"
readonly HANDOFF_SIGNAL="$STATE_DIR/.handoff-requested"
readonly PID_FILE="$STATE_DIR/.claude-agi.pid"
readonly LOG_FILE="$STATE_DIR/orchestrator.log"

# Token monitoring
readonly TOKEN_LIMIT=100000
readonly HANDOFF_THRESHOLD=80

# Output control (can be overridden by flags)
VERBOSE=false
QUIET=false

# Colors
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly NC='\033[0m' # No Color

# Logging
log() {
    local level="${1:-INFO}"
    shift
    local msg="$*"
    local timestamp
    timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$timestamp] [$level] $msg" >> "$LOG_FILE"

    case "$level" in
        ERROR) echo -e "${RED}ERROR: $msg${NC}" >&2 ;;
        WARN)  echo -e "${YELLOW}WARN: $msg${NC}" ;;
        INFO)  echo -e "${BLUE}INFO: $msg${NC}" ;;
        OK)    echo -e "${GREEN}✓ $msg${NC}" ;;
    esac
}

# Print usage
usage() {
    cat << EOF
claude-agi v${VERSION} - Autonomous Claude Code Orchestrator

Usage:
    claude-agi                     Start new execution (interactive)
    claude-agi --continue          Resume from checkpoint
    claude-agi --overnight         Start overnight mode (no prompts)
    claude-agi --verbose, -v       Show detailed debug output
    claude-agi --quiet, -q         Minimal output (only errors)
    claude-agi --status            Show execution status
    claude-agi --cancel            Cancel execution and cleanup
    claude-agi --help              Show this help

PREREQUISITE:
    Before running claude-agi, you MUST run /auto-prepare first!

    claude-agi reads state files created by /auto-prepare:
      - .claude/auto-execution/state.yaml
      - .claude/auto-execution/tasks.json
      - .claude/auto-execution/next-session.md

    Workflow:
      1. claude -p "/auto-prepare <describe your task>"
         (This plans interactively and creates state files)

      2. claude-agi --overnight
         (This executes the prepared plan)

    NOTE: /do is for in-session execution (runs immediately).
          For overnight mode, use /auto-prepare + claude-agi.

Environment:
    CLAUDE_AGI_MAX_SESSIONS     Maximum sessions before stopping (default: 50)
    CLAUDE_AGI_SESSION_TIMEOUT  Session timeout in seconds (default: 3600)
    CLAUDE_AGI_VERBOSE          Enable verbose mode (default: false)
    CLAUDE_AGI_QUIET            Enable quiet mode (default: false)

Examples:
    # Prepare first (in a Claude session)
    claude -p "/auto-prepare Build user authentication with OAuth"

    # Then run overnight
    claude-agi --overnight

    # Or interactive
    claude-agi

    # Resume after session interrupt
    claude-agi --continue
EOF
}

# Check prerequisites
check_prerequisites() {
    # Check for claude command
    if ! command -v claude &> /dev/null; then
        log ERROR "Claude CLI not found. Please install claude-code first."
        exit 1
    fi

    # Check for state files
    if [[ ! -f "$STATE_FILE" ]]; then
        log ERROR "No execution state found at $STATE_FILE"
        echo ""
        echo "claude-agi requires state files created by /auto-prepare."
        echo ""
        echo "To prepare for autonomous execution:"
        echo "  1. Start a Claude session: claude"
        echo "  2. Run: /auto-prepare <describe your task>"
        echo "  3. Follow the interactive planning process"
        echo "  4. Once done, exit and run: claude-agi --overnight"
        echo ""
        echo "NOTE: /do is for in-session execution and does NOT create"
        echo "      state files for claude-agi. Use /auto-prepare instead."
        exit 1
    fi

    # Create log file if needed
    mkdir -p "$(dirname "$LOG_FILE")"
    touch "$LOG_FILE"
}

# Read state
read_state() {
    if [[ ! -f "$STATE_FILE" ]]; then
        echo "none"
        return
    fi

    # Parse YAML status field (simple grep-based parsing)
    grep -E "^status:" "$STATE_FILE" | sed 's/status: *//' | tr -d '"' || echo "none"
}

# Update state
update_state() {
    local new_status="$1"
    local reason="${2:-}"

    if [[ -f "$STATE_FILE" ]]; then
        # Update status field
        sed -i.bak "s/^status:.*/status: \"$new_status\"/" "$STATE_FILE"
        rm -f "$STATE_FILE.bak"

        # Add session history entry
        local timestamp
        timestamp=$(date -u '+%Y-%m-%dT%H:%M:%SZ')

        # Append to session_history if reason provided
        if [[ -n "$reason" ]]; then
            log INFO "State updated: $new_status ($reason)"
        fi
    fi
}

# Check for handoff signal
check_handoff_signal() {
    if [[ -f "$HANDOFF_SIGNAL" ]]; then
        log INFO "Handoff signal detected"
        rm -f "$HANDOFF_SIGNAL"
        return 0
    fi
    return 1
}

# Create handoff signal
request_handoff() {
    touch "$HANDOFF_SIGNAL"
    log INFO "Handoff requested"
}

# Start a Claude session
start_session() {
    local mode="${1:-interactive}"
    local session_num="${2:-1}"

    log INFO "Starting session $session_num (mode: $mode)"

    # Build command based on mode
    local claude_cmd="claude"
    local args=()

    # Output control
    if [[ "$QUIET" == "true" ]]; then
        # Quiet mode - no streaming, just run
        :
    else
        # Normal/verbose - stream output to terminal
        args+=("--print")
    fi

    # Verbose mode - add debug output
    if [[ "$VERBOSE" == "true" ]]; then
        args+=("--verbose")
    fi

    if [[ "$mode" == "overnight" ]]; then
        args+=("--dangerously-skip-permissions")
    fi

    # Execute claude with appropriate command
    if [[ "$session_num" -eq 1 ]]; then
        # First session - start execution
        args+=("-p" "/auto-execute")
    else
        # Continuation session
        args+=("-p" "/auto-execute --continue")
    fi

    if [[ "$VERBOSE" == "true" ]]; then
        log INFO "Running: $claude_cmd ${args[*]}"
    fi

    # Run claude and capture exit code
    local exit_code=0
    "$claude_cmd" "${args[@]}" || exit_code=$?

    return "$exit_code"
}

# Run interactive mode
run_interactive() {
    log INFO "Starting interactive execution"

    update_state "in_progress"

    # Write PID
    echo $$ > "$PID_FILE"

    local session_num=1
    local max_sessions=${CLAUDE_AGI_MAX_SESSIONS:-50}

    while [[ $session_num -le $max_sessions ]]; do
        log INFO "Session $session_num of $max_sessions"

        # Start session
        start_session "interactive" "$session_num"
        local exit_code=$?

        # Check execution status
        local status
        status=$(read_state)

        case "$status" in
            "completed")
                log OK "Execution completed successfully!"
                break
                ;;
            "stuck")
                log WARN "Execution stuck. Check stuck-report.md"
                break
                ;;
            "cancelled")
                log WARN "Execution cancelled"
                break
                ;;
            "in_progress"|"handoff_pending")
                # Check for handoff signal
                if check_handoff_signal; then
                    log INFO "Continuing with new session..."
                    ((session_num++))
                    continue
                fi
                ;;
            *)
                if [[ $exit_code -ne 0 ]]; then
                    log ERROR "Session exited with error code $exit_code"
                    break
                fi
                ;;
        esac

        # If we get here without handoff, assume complete or manual exit
        break
    done

    # Cleanup
    rm -f "$PID_FILE"

    log INFO "Orchestrator finished after $session_num session(s)"
}

# Run overnight mode
run_overnight() {
    log INFO "Starting overnight execution (unattended)"

    update_state "in_progress"

    # Write PID
    echo $$ > "$PID_FILE"

    local session_num=1
    local max_sessions=${CLAUDE_AGI_MAX_SESSIONS:-50}
    local consecutive_failures=0
    local max_consecutive_failures=3

    while [[ $session_num -le $max_sessions ]]; do
        log INFO "Overnight session $session_num of $max_sessions"

        # Start session with overnight flags
        start_session "overnight" "$session_num"
        local exit_code=$?

        # Check execution status
        local status
        status=$(read_state)

        case "$status" in
            "completed")
                log OK "Overnight execution completed successfully!"
                consecutive_failures=0
                break
                ;;
            "stuck")
                log WARN "Execution stuck. Check stuck-report.md"
                ((consecutive_failures++))

                if [[ $consecutive_failures -ge $max_consecutive_failures ]]; then
                    log ERROR "Too many consecutive failures. Stopping."
                    break
                fi

                log INFO "Attempting retry in new session..."
                ;;
            "cancelled")
                log WARN "Execution cancelled"
                break
                ;;
            "in_progress"|"handoff_pending")
                # Normal handoff - continue
                consecutive_failures=0
                log INFO "Handoff - starting new session..."
                ;;
            *)
                if [[ $exit_code -ne 0 ]]; then
                    ((consecutive_failures++))
                    log WARN "Session error (failures: $consecutive_failures)"

                    if [[ $consecutive_failures -ge $max_consecutive_failures ]]; then
                        log ERROR "Too many consecutive failures. Stopping."
                        break
                    fi
                fi
                ;;
        esac

        ((session_num++))

        # Small delay between sessions
        sleep 2
    done

    # Cleanup
    rm -f "$PID_FILE"

    # Final status
    local final_status
    final_status=$(read_state)

    if [[ "$final_status" == "completed" ]]; then
        log OK "Overnight execution finished successfully after $session_num session(s)"
    else
        log WARN "Overnight execution ended with status: $final_status"
    fi
}

# Resume from checkpoint
run_continue() {
    log INFO "Resuming execution from checkpoint"

    local status
    status=$(read_state)

    case "$status" in
        "completed")
            log OK "Execution already completed!"
            exit 0
            ;;
        "cancelled")
            log WARN "Execution was cancelled. Start fresh with: claude-agi"
            exit 1
            ;;
        "none")
            log ERROR "No execution state found. Run /auto-prepare in a Claude session first."
            exit 1
            ;;
        *)
            log INFO "Resuming from status: $status"
            ;;
    esac

    # Continue with interactive mode
    run_interactive
}

# Show status
show_status() {
    echo "═══════════════════════════════════════════════════════════"
    echo " claude-agi Status"
    echo "═══════════════════════════════════════════════════════════"

    if [[ ! -f "$STATE_FILE" ]]; then
        echo " Status: No execution in progress"
        echo " Hint: Run /auto-prepare to create execution plan"
        return
    fi

    # Parse state
    local status
    status=$(read_state)

    # Get task counts
    local tasks_file="$STATE_DIR/tasks.json"
    local total=0
    local done=0
    local in_progress=0
    local stuck=0

    if [[ -f "$tasks_file" ]] && command -v jq &> /dev/null; then
        total=$(jq '.tasks | length' "$tasks_file" 2>/dev/null || echo 0)
        done=$(jq '[.tasks[] | select(.status=="done")] | length' "$tasks_file" 2>/dev/null || echo 0)
        in_progress=$(jq '[.tasks[] | select(.status=="in_progress")] | length' "$tasks_file" 2>/dev/null || echo 0)
        stuck=$(jq '[.tasks[] | select(.status=="stuck")] | length' "$tasks_file" 2>/dev/null || echo 0)
    fi

    echo ""
    echo " Status: $status"
    echo " Progress: $done/$total tasks completed"

    if [[ $in_progress -gt 0 ]]; then
        echo " In Progress: $in_progress"
    fi
    if [[ $stuck -gt 0 ]]; then
        echo " Stuck: $stuck"
    fi

    # Check if orchestrator is running
    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            echo " Orchestrator: Running (PID: $pid)"
        else
            echo " Orchestrator: Not running (stale PID file)"
        fi
    else
        echo " Orchestrator: Not running"
    fi

    echo ""
    echo "═══════════════════════════════════════════════════════════"
}

# Cancel execution
cancel_execution() {
    log WARN "Cancelling execution..."

    # Kill running orchestrator if any
    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null || true
            log INFO "Killed orchestrator process $pid"
        fi
        rm -f "$PID_FILE"
    fi

    # Update state
    update_state "cancelled" "user_requested"

    # Cleanup handoff signal
    rm -f "$HANDOFF_SIGNAL"

    log OK "Execution cancelled"
}

# Main entry point
main() {
    local mode="interactive"

    # Check environment variables
    VERBOSE="${CLAUDE_AGI_VERBOSE:-false}"
    QUIET="${CLAUDE_AGI_QUIET:-false}"

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --continue|-c)
                mode="continue"
                shift
                ;;
            --overnight|-o)
                mode="overnight"
                shift
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            --quiet|-q)
                QUIET=true
                shift
                ;;
            --status|-s)
                show_status
                exit 0
                ;;
            --cancel)
                cancel_execution
                exit 0
                ;;
            --help|-h)
                usage
                exit 0
                ;;
            --version)
                echo "claude-agi v${VERSION}"
                exit 0
                ;;
            *)
                echo "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done

    # Verbose and quiet are mutually exclusive
    if [[ "$VERBOSE" == "true" && "$QUIET" == "true" ]]; then
        log WARN "Both --verbose and --quiet specified. Using --verbose."
        QUIET=false
    fi

    if [[ "$VERBOSE" == "true" ]]; then
        log INFO "Verbose mode enabled"
    fi

    # Check prerequisites
    check_prerequisites

    # Run based on mode
    case "$mode" in
        interactive)
            run_interactive
            ;;
        overnight)
            run_overnight
            ;;
        continue)
            run_continue
            ;;
    esac
}

# Run main
main "$@"
