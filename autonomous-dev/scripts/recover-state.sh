#!/bin/bash
# =============================================================================
# STATE RECOVERY SCRIPT v1.0
# =============================================================================
# Recovers from corrupted or inconsistent state files.
# Creates backups before any modifications.
# =============================================================================

set -euo pipefail

STATE_FILE=".claude/auto-progress.yaml"
STATE_MACHINE_FILE=".claude/auto-state-machine.yaml"
CONTEXT_FILE=".claude/auto-context.yaml"
MEMORY_DIR=".claude/auto-memory"
BACKUP_DIR=".claude/backups"

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
NC='\033[0m'

if [[ ! -t 1 ]]; then
    RED=''
    GREEN=''
    YELLOW=''
    NC=''
fi

# =============================================================================
# HELPER FUNCTIONS
# =============================================================================

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

create_backup() {
    local file="$1"
    if [[ -f "$file" ]]; then
        mkdir -p "$BACKUP_DIR"
        local timestamp
        timestamp=$(date +%Y%m%d-%H%M%S)
        local backup_name
        backup_name=$(basename "$file")-$timestamp
        cp "$file" "$BACKUP_DIR/$backup_name"
        log_info "Backed up $file to $BACKUP_DIR/$backup_name"
    fi
}

# =============================================================================
# RECOVERY COMMANDS
# =============================================================================

diagnose() {
    echo "=== State Diagnosis ==="
    echo ""

    # Check progress file
    echo "--- Progress File (.claude/auto-progress.yaml) ---"
    if [[ -f "$STATE_FILE" ]]; then
        if yq empty "$STATE_FILE" 2>/dev/null; then
            echo -e "${GREEN}Valid YAML${NC}"
            echo "Status: $(yq -r '.status // "unknown"' "$STATE_FILE")"
            echo "Iteration: $(yq -r '.iteration // 0' "$STATE_FILE")"
        else
            echo -e "${RED}Invalid YAML - needs repair${NC}"
        fi
    else
        echo "Does not exist"
    fi
    echo ""

    # Check state machine
    echo "--- State Machine (.claude/auto-state-machine.yaml) ---"
    if [[ -f "$STATE_MACHINE_FILE" ]]; then
        if yq empty "$STATE_MACHINE_FILE" 2>/dev/null; then
            echo -e "${GREEN}Valid YAML${NC}"
            echo "State: $(yq -r '.current_state // "unknown"' "$STATE_MACHINE_FILE")"
            echo "Work Type: $(yq -r '.work_type // "unknown"' "$STATE_MACHINE_FILE")"
        else
            echo -e "${RED}Invalid YAML - needs repair${NC}"
        fi
    else
        echo "Does not exist"
    fi
    echo ""

    # Check worktrees
    echo "--- Git Worktrees ---"
    git worktree list 2>/dev/null || echo "Git not available"
    echo ""

    # Check memory
    echo "--- Memory Files ---"
    if [[ -d "$MEMORY_DIR" ]]; then
        ls -la "$MEMORY_DIR" 2>/dev/null || echo "Empty"
    else
        echo "Memory directory does not exist"
    fi
}

reset_progress() {
    log_warn "Resetting progress file..."
    create_backup "$STATE_FILE"

    cat > "$STATE_FILE" << 'EOF'
# Auto-generated by recover-state.sh
status: idle
iteration: 0
max_iterations: 50
EOF

    log_info "Progress file reset to idle state"
}

reset_state_machine() {
    log_warn "Resetting state machine..."
    create_backup "$STATE_MACHINE_FILE"

    cat > "$STATE_MACHINE_FILE" << 'EOF'
# Auto-generated by recover-state.sh
version: "3.0"
current_state: IDLE
work_type: ""
session_id: ""
classification_confidence: 0
mandatory_skills: []
completed_phases: []
token_usage:
  budget: 200000
  estimated: 0
  warning_threshold: 0.80
  checkpoint_threshold: 0.95
EOF

    log_info "State machine reset to IDLE"
}

clean_worktrees() {
    log_warn "Cleaning up worktrees..."

    # Prune deleted worktrees
    git worktree prune 2>/dev/null || true

    # Remove auto-* worktrees
    for worktree in /tmp/auto-worktrees/*/; do
        if [[ -d "$worktree" ]]; then
            local name
            name=$(basename "$worktree")
            log_info "Removing worktree: $name"
            git worktree remove "$worktree" --force 2>/dev/null || rm -rf "$worktree"
        fi
    done

    # Delete auto/* branches
    for branch in $(git branch --list 'auto/*' 2>/dev/null | tr -d ' *'); do
        log_info "Deleting branch: $branch"
        git branch -D "$branch" 2>/dev/null || true
    done

    log_info "Worktree cleanup complete"
}

clean_all() {
    log_warn "Performing full cleanup..."

    # Backup everything first
    create_backup "$STATE_FILE"
    create_backup "$STATE_MACHINE_FILE"
    create_backup "$CONTEXT_FILE"

    # Remove state files
    rm -f "$STATE_FILE" "$STATE_MACHINE_FILE" "$CONTEXT_FILE"

    # Archive memory
    if [[ -d "$MEMORY_DIR" ]]; then
        local archive
        archive="$BACKUP_DIR/memory-$(date +%Y%m%d-%H%M%S)"
        mkdir -p "$archive"
        mv "$MEMORY_DIR"/* "$archive/" 2>/dev/null || true
        rm -rf "$MEMORY_DIR"
    fi

    # Clean worktrees
    clean_worktrees

    log_info "Full cleanup complete. Backups in $BACKUP_DIR"
}

restore_from_backup() {
    local backup_file="${1:-}"

    if [[ -z "$backup_file" ]]; then
        echo "Available backups:"
        ls -la "$BACKUP_DIR" 2>/dev/null || echo "No backups found"
        echo ""
        echo "Usage: $0 restore <backup-filename>"
        return 1
    fi

    local backup_path="$BACKUP_DIR/$backup_file"
    if [[ ! -f "$backup_path" ]]; then
        log_error "Backup file not found: $backup_path"
        return 1
    fi

    # Determine target based on filename
    local target
    if [[ "$backup_file" == auto-progress.yaml* ]]; then
        target="$STATE_FILE"
    elif [[ "$backup_file" == auto-state-machine.yaml* ]]; then
        target="$STATE_MACHINE_FILE"
    elif [[ "$backup_file" == auto-context.yaml* ]]; then
        target="$CONTEXT_FILE"
    else
        log_error "Unknown backup type: $backup_file"
        return 1
    fi

    log_info "Restoring $backup_path to $target"
    cp "$backup_path" "$target"
    log_info "Restore complete"
}

# =============================================================================
# MAIN
# =============================================================================

case "${1:-help}" in
    "diagnose"|"status")
        diagnose
        ;;
    "reset-progress")
        reset_progress
        ;;
    "reset-state")
        reset_state_machine
        ;;
    "clean-worktrees")
        clean_worktrees
        ;;
    "clean-all")
        clean_all
        ;;
    "restore")
        restore_from_backup "${2:-}"
        ;;
    "help"|*)
        cat << 'EOF'
State Recovery Script v1.0

Usage:
  recover-state.sh diagnose         Show current state health
  recover-state.sh reset-progress   Reset progress file to idle
  recover-state.sh reset-state      Reset state machine to IDLE
  recover-state.sh clean-worktrees  Remove all auto-* worktrees and branches
  recover-state.sh clean-all        Full cleanup (with backups)
  recover-state.sh restore <file>   Restore from backup

Examples:
  # Check what's wrong
  recover-state.sh diagnose

  # Soft reset (keep memory)
  recover-state.sh reset-progress
  recover-state.sh reset-state

  # Hard reset (clean everything)
  recover-state.sh clean-all

  # Restore previous state
  recover-state.sh restore auto-progress.yaml-20250117-120000
EOF
        ;;
esac
